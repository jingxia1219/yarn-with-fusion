"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prepare;

var React = _interopRequireWildcard(require("react"));

var _reactSsrPrepass = _interopRequireDefault(require("react-ssr-prepass"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class PrepareState {
  constructor() {
    this.seen = new Map();
    this.pending = new Map();
  }

  isResolved(Component, effectId, effectPromiseThunk) {
    let seenEffectIds = this.seen.get(Component);
    let pendingPromises = this.pending.get(Component); // Initialize if not present

    if (!seenEffectIds) {
      seenEffectIds = new Set();
      this.seen.set(Component, seenEffectIds);
    } // If seen and not pending, then it has been resolved


    if (seenEffectIds.has(effectId) && (!pendingPromises || !pendingPromises.has(effectId))) {
      return true;
    } // If not yet seen, need to start promise


    if (!seenEffectIds.has(effectId)) {
      if (!pendingPromises) {
        pendingPromises = new Map();
        this.pending.set(Component, pendingPromises);
      }

      const effectPromise = effectPromiseThunk();
      seenEffectIds.add(effectId);
      pendingPromises.set(effectId, effectPromise);
    }

    return false;
  }

  consumeAndAwaitPromises() {
    let promises = [];

    for (let map of this.pending.values()) {
      for (let promise of map.values()) {
        promises.push(promise);
      }
    }

    this.pending = new Map(); // clear

    return Promise.all(promises);
  }

}

function prepare(element, ctx) {
  const prepareState = new PrepareState();

  class PrepareContextProvider extends React.Component {
    getChildContext() {
      return {
        __IS_PREPARE__: true,
        __PREPARE_STATE__: prepareState
      };
    }

    render() {
      return element;
    }

  }

  _defineProperty(PrepareContextProvider, "childContextTypes", {
    __PREPARE_STATE__: _propTypes.default.any,
    __IS_PREPARE__: _propTypes.default.any
  });

  async function process() {
    if (ctx && ctx.timing) {
      ctx.timing.markPrepass();
    }

    await (0, _reactSsrPrepass.default)( /*#__PURE__*/React.createElement(PrepareContextProvider));

    if (ctx && ctx.timing) {
      ctx.timing.markPrepass(prepareState.pending.size);
    }

    if (prepareState.pending.size) {
      return prepareState.consumeAndAwaitPromises().then(process);
    }
  }

  return Promise.resolve().then(process);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hc3luYy9wcmVwYXJlLmpzIl0sIm5hbWVzIjpbIlByZXBhcmVTdGF0ZSIsImNvbnN0cnVjdG9yIiwic2VlbiIsIk1hcCIsInBlbmRpbmciLCJpc1Jlc29sdmVkIiwiQ29tcG9uZW50IiwiZWZmZWN0SWQiLCJlZmZlY3RQcm9taXNlVGh1bmsiLCJzZWVuRWZmZWN0SWRzIiwiZ2V0IiwicGVuZGluZ1Byb21pc2VzIiwiU2V0Iiwic2V0IiwiaGFzIiwiZWZmZWN0UHJvbWlzZSIsImFkZCIsImNvbnN1bWVBbmRBd2FpdFByb21pc2VzIiwicHJvbWlzZXMiLCJtYXAiLCJ2YWx1ZXMiLCJwcm9taXNlIiwicHVzaCIsIlByb21pc2UiLCJhbGwiLCJwcmVwYXJlIiwiZWxlbWVudCIsImN0eCIsInByZXBhcmVTdGF0ZSIsIlByZXBhcmVDb250ZXh0UHJvdmlkZXIiLCJSZWFjdCIsImdldENoaWxkQ29udGV4dCIsIl9fSVNfUFJFUEFSRV9fIiwiX19QUkVQQVJFX1NUQVRFX18iLCJyZW5kZXIiLCJQcm9wVHlwZXMiLCJhbnkiLCJwcm9jZXNzIiwidGltaW5nIiwibWFya1ByZXBhc3MiLCJjcmVhdGVFbGVtZW50Iiwic2l6ZSIsInRoZW4iLCJyZXNvbHZlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBUUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxNQUFNQSxZQUFOLENBQW1CO0FBSWpCQyxFQUFBQSxXQUFXLEdBQUc7QUFDWixTQUFLQyxJQUFMLEdBQVksSUFBSUMsR0FBSixFQUFaO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQUlELEdBQUosRUFBZjtBQUNEOztBQUVERSxFQUFBQSxVQUFVLENBQUNDLFNBQUQsRUFBWUMsUUFBWixFQUFzQkMsa0JBQXRCLEVBQTBDO0FBQ2xELFFBQUlDLGFBQWEsR0FBRyxLQUFLUCxJQUFMLENBQVVRLEdBQVYsQ0FBY0osU0FBZCxDQUFwQjtBQUNBLFFBQUlLLGVBQWUsR0FBRyxLQUFLUCxPQUFMLENBQWFNLEdBQWIsQ0FBaUJK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RDtBQUNGOztBQUVELFNBQU9kLE9BQU8sQ0FBQ29CLE9BQVIsR0FBa0JELElBQWxCLENBQXVCTCxPQUF2QixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQ29weXJpZ2h0IChjKSAyMDE4IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3NyUHJlcGFzcyBmcm9tICdyZWFjdC1zc3ItcHJlcGFzcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBQcmVwYXJlU3RhdGUge1xuICBzZWVuOiBNYXA8YW55LCBTZXQ8c3RyaW5nPj47XG4gIHBlbmRpbmc6IE1hcDxhbnksIE1hcDxzdHJpbmcsIFByb21pc2U8YW55Pj4+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VlbiA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBlbmRpbmcgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBpc1Jlc29sdmVkKENvbXBvbmVudCwgZWZmZWN0SWQsIGVmZmVjdFByb21pc2VUaHVuaykge1xuICAgIGxldCBzZWVuRWZmZWN0SWRzID0gdGhpcy5zZWVuLmdldChDb21wb25lbnQpO1xuICAgIGxldCBwZW5kaW5nUHJvbWlzZXMgPSB0aGlzLnBlbmRpbmcuZ2V0KENvbXBvbmVudCk7XG5cbiAgICAvLyBJbml0aWFsaXplIGlmIG5vdCBwcmVzZW50XG4gICAgaWYgKCFzZWVuRWZmZWN0SWRzKSB7XG4gICAgICBzZWVuRWZmZWN0SWRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5zZWVuLnNldChDb21wb25lbnQsIHNlZW5FZmZlY3RJZHMpO1xuICAgIH1cblxuICAgIC8vIElmIHNlZW4gYW5kIG5vdCBwZW5kaW5nLCB0aGVuIGl0IGhhcyBiZWVuIHJlc29sdmVkXG4gICAgaWYgKFxuICAgICAgc2VlbkVmZmVjdElkcy5oYXMoZWZmZWN0SWQpICYmXG4gICAgICAoIXBlbmRpbmdQcm9taXNlcyB8fCAhcGVuZGluZ1Byb21pc2VzLmhhcyhlZmZlY3RJZCkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiBub3QgeWV0IHNlZW4sIG5lZWQgdG8gc3RhcnQgcHJvbWlzZVxuICAgIGlmICghc2VlbkVmZmVjdElkcy5oYXMoZWZmZWN0SWQpKSB7XG4gICAgICBpZiAoIXBlbmRpbmdQcm9taXNlcykge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZy5zZXQoQ29tcG9uZW50LCBwZW5kaW5nUHJvbWlzZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlZmZlY3RQcm9taXNlID0gZWZmZWN0UHJvbWlzZVRodW5rKCk7XG4gICAgICBzZWVuRWZmZWN0SWRzLmFkZChlZmZlY3RJZCk7XG4gICAgICBwZW5kaW5nUHJvbWlzZXMuc2V0KGVmZmVjdElkLCBlZmZlY3RQcm9taXNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdW1lQW5kQXdhaXRQcm9taXNlcygpIHtcbiAgICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGxldCBtYXAgb2YgdGhpcy5wZW5kaW5nLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGxldCBwcm9taXNlIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGVuZGluZyA9IG5ldyBNYXAoKTsgLy8gY2xlYXJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXBhcmUoZWxlbWVudDogYW55LCBjdHg6IGFueSkge1xuICBjb25zdCBwcmVwYXJlU3RhdGUgPSBuZXcgUHJlcGFyZVN0YXRlKCk7XG5cbiAgY2xhc3MgUHJlcGFyZUNvbnRleHRQcm92aWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7fT4ge1xuICAgIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9fSVNfUFJFUEFSRV9fOiB0cnVlLFxuICAgICAgICBfX1BSRVBBUkVfU1RBVEVfXzogcHJlcGFyZVN0YXRlLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgIF9fUFJFUEFSRV9TVEFURV9fOiBQcm9wVHlwZXMuYW55LFxuICAgICAgX19JU19QUkVQQVJFX186IFByb3BUeXBlcy5hbnksXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgaWYgKGN0eCAmJiBjdHgudGltaW5nKSB7XG4gICAgICBjdHgudGltaW5nLm1hcmtQcmVwYXNzKCk7XG4gICAgfVxuICAgIGF3YWl0IHNzclByZXBhc3MoUmVhY3QuY3JlYXRlRWxlbWVudChQcmVwYXJlQ29udGV4dFByb3ZpZGVyKSk7XG4gICAgaWYgKGN0eCAmJiBjdHgudGltaW5nKSB7XG4gICAgICBjdHgudGltaW5nLm1hcmtQcmVwYXNzKHByZXBhcmVTdGF0ZS5wZW5kaW5nLnNpemUpO1xuICAgIH1cbiAgICBpZiAocHJlcGFyZVN0YXRlLnBlbmRpbmcuc2l6ZSkge1xuICAgICAgcmV0dXJuIHByZXBhcmVTdGF0ZS5jb25zdW1lQW5kQXdhaXRQcm9taXNlcygpLnRoZW4ocHJvY2Vzcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4ocHJvY2Vzcyk7XG59XG4iXX0=