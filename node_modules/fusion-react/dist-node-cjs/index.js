"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  SkipPrepareToken: true,
  ProviderPlugin: true,
  ProvidedHOC: true,
  Provider: true,
  FusionContext: true,
  ServiceConsumer: true,
  ServiceContext: true,
  useService: true,
  withServices: true
};
Object.defineProperty(exports, "ProviderPlugin", {
  enumerable: true,
  get: function () {
    return _plugin.default;
  }
});
Object.defineProperty(exports, "ProvidedHOC", {
  enumerable: true,
  get: function () {
    return _hoc.default;
  }
});
Object.defineProperty(exports, "Provider", {
  enumerable: true,
  get: function () {
    return _provider.default;
  }
});
Object.defineProperty(exports, "FusionContext", {
  enumerable: true,
  get: function () {
    return _context.FusionContext;
  }
});
Object.defineProperty(exports, "ServiceConsumer", {
  enumerable: true,
  get: function () {
    return _context.ServiceConsumer;
  }
});
Object.defineProperty(exports, "ServiceContext", {
  enumerable: true,
  get: function () {
    return _context.ServiceContext;
  }
});
Object.defineProperty(exports, "useService", {
  enumerable: true,
  get: function () {
    return _context.useService;
  }
});
Object.defineProperty(exports, "withServices", {
  enumerable: true,
  get: function () {
    return _context.withServices;
  }
});
exports.default = exports.SkipPrepareToken = void 0;

var React = _interopRequireWildcard(require("react"));

var _fusionCore = _interopRequireWildcard(require("fusion-core"));

var _index = require("./async/index.js");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

var _prepareProvider = _interopRequireDefault(require("./async/prepare-provider"));

var _fusionTokens = require("fusion-tokens");

var _server = _interopRequireDefault(require("./server"));

var _plugin = _interopRequireDefault(require("./plugin"));

var _hoc = _interopRequireDefault(require("./hoc"));

var _provider = _interopRequireDefault(require("./provider"));

var _context = require("./context.js");

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
const SkipPrepareToken = (0, _fusionCore.createToken)('SkipPrepareToken');
exports.SkipPrepareToken = SkipPrepareToken;

class App extends _fusionCore.default {
  constructor(root, render) {
    if (! /*#__PURE__*/React.isValidElement(root)) {
      throw new Error('Invalid React element. Ensure your root element is a React.Element (e.g. <Foo />) and not a React.Component (e.g. Foo)');
    }

    const getService = token => {
      // $FlowFixMe
      const provides = this.getService(token);
      const isRequiredToken = Boolean(token.optional);

      if (typeof provides === 'undefined' && isRequiredToken) {
        throw new Error(`Token ${token.name} not registered or registered plugin does not provide a service. To use an optional plugin, use \`Token.optional\`.`);
      }

      return provides;
    };

    const renderer = (0, _fusionCore.createPlugin)({
      deps: {
        criticalChunkIds: _fusionCore.CriticalChunkIdsToken.optional,
        skipPrepare: SkipPrepareToken.optional,
        logger: _fusionTokens.LoggerToken.optional
      },

      provides({
        skipPrepare,
        logger
      }) {
        return (el, ctx) => {
          return (skipPrepare ? Promise.resolve() : (0, _index.prepare)(el, ctx)).catch(() => {}) // recover from failed `prepare`
          .then(() => {
            if (render) {
              return render(el, ctx);
            }

            if (true) {
              return (0, _server.default)(el, logger);
            } else {
              return clientRender(el);
            }
          });
        };
      },

      middleware({
        criticalChunkIds
      }) {
        return (ctx, next) => {
          if (true && !ctx.element) {
            return next();
          }

          const markAsCritical = true ? chunkId => {
            // Push to legacy context for backwards compat w/ legacy SSR template
            ctx.preloadChunks.push(chunkId); // Also use new service if registered

            if (criticalChunkIds) {
              let chunkIds = criticalChunkIds.from(ctx);
              chunkIds.add(chunkId);
            }
          } : noop; // This is used to collect arbitrary metadata during a given SSR
          // The primary use case is to collect bundler-specific information
          // about import() statements encountered during SSR so that async
          // bundle-split client code can be preloaded/fetched appropriately

          ctx.ssrMetadata = [];
          const pushSSRMetadata = true ? metadata => {
            ctx.ssrMetadata.push(metadata);
          } : noop;
          ctx.element = /*#__PURE__*/(0, _jsxRuntime.jsx)(_prepareProvider.default, {
            markAsCritical: markAsCritical,
            pushSSRMetadata: pushSSRMetadata,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_context.FusionContext.Provider, {
              value: ctx,
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_context.ServiceContext.Provider, {
                value: getService,
                children: ctx.element
              })
            })
          });
          return next();
        };
      }

    });
    super(root, renderer);
  }

}

exports.default = App;

function noop() {}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTa2lwUHJlcGFyZVRva2VuIiwiQXBwIiwiRnVzaW9uQXBwIiwiY29uc3RydWN0b3IiLCJyb290IiwicmVuZGVyIiwiUmVhY3QiLCJpc1ZhbGlkRWxlbWVudCIsIkVycm9yIiwiZ2V0U2VydmljZSIsInRva2VuIiwicHJvdmlkZXMiLCJpc1JlcXVpcmVkVG9rZW4iLCJCb29sZWFuIiwib3B0aW9uYWwiLCJuYW1lIiwicmVuZGVyZXIiLCJkZXBzIiwiY3JpdGljYWxDaHVua0lkcyIsIkNyaXRpY2FsQ2h1bmtJZHNUb2tlbiIsInNraXBQcmVwYXJlIiwibG9nZ2VyIiwiTG9nZ2VyVG9rZW4iLCJlbCIsImN0eCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwiY2xpZW50UmVuZGVyIiwibWlkZGxld2FyZSIsIm5leHQiLCJlbGVtZW50IiwibWFya0FzQ3JpdGljYWwiLCJjaHVua0lkIiwicHJlbG9hZENodW5rcyIsInB1c2giLCJjaHVua0lkcyIsImZyb20iLCJhZGQiLCJub29wIiwic3NyTWV0YWRhdGEiLCJwdXNoU1NSTWV0YWRhdGEiLCJtZXRhZGF0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU0E7O0FBRUE7O0FBTUE7O0FBZ0lBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBL0hBOztBQUNBOztBQUVBOztBQUdBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBNEJPLE1BQU1BLGdCQUFnQixHQUFHLDZCQUFxQixrQkFBckIsQ0FBekI7OztBQU1RLE1BQU1DLEdBQU4sU0FBa0JDLG1CQUFsQixDQUE0QjtBQUN6Q0MsRUFBQUEsV0FBVyxDQUFDQyxJQUFELEVB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Q0FBZSxRQUFmO0FBQXdCLGNBQUEsS0FBSyxFQUFFbEIsR0FBL0I7QUFBQSxxQ0FDRSxxQkFBQyx1QkFBRCxDQUFnQixRQUFoQjtBQUF5QixnQkFBQSxLQUFLLEVBQUVmLFVBQWhDO0FBQUEsMEJBQ0dlLEdBQUcsQ0FBQ1E7QUFEUDtBQURGO0FBSkYsWUFERjtBQVlBLGlCQUFPRCxJQUFJLEVBQVg7QUFDRCxTQTFDRDtBQTJDRDs7QUFsRTJCLEtBQWIsQ0FBakI7QUFvRUEsVUFBTTNCLElBQU4sRUFBWVksUUFBWjtBQUNEOztBQXZGd0M7Ozs7QUFxRzNDLFNBQVN3QixJQUFULEdBQWdCLENBQUUiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQ29weXJpZ2h0IChjKSAyMDE4IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEZ1c2lvbkFwcCwge1xuICBjcmVhdGVUb2tlbixcbiAgY3JlYXRlUGx1Z2luLFxuICBDcml0aWNhbENodW5rSWRzVG9rZW4sXG4gIHR5cGUgQ29udGV4dCxcbn0gZnJvbSAnZnVzaW9uLWNvcmUnO1xuaW1wb3J0IHtwcmVwYXJlfSBmcm9tICcuL2FzeW5jL2luZGV4LmpzJztcbmltcG9ydCBQcmVwYXJlUHJvdmlkZXIgZnJvbSAnLi9hc3luYy9wcmVwYXJlLXByb3ZpZGVyJztcbmltcG9ydCB7TG9nZ2VyVG9rZW59IGZyb20gJ2Z1c2lvbi10b2tlbnMnO1xuXG5pbXBvcnQgc2VydmVyUmVuZGVyIGZyb20gJy4vc2VydmVyJztcbmltcG9ydCBjbGllbnRSZW5kZXIgZnJvbSAnLi9jbGllbnQnO1xuXG5pbXBvcnQgUHJvdmlkZXJQbHVnaW4gZnJvbSAnLi9wbHVnaW4nO1xuaW1wb3J0IFByb3ZpZGVkSE9DIGZyb20gJy4vaG9jJztcbmltcG9ydCBQcm92aWRlciBmcm9tICcuL3Byb3ZpZGVyJztcblxuaW1wb3J0IHtcbiAgRnVzaW9uQ29udGV4dCxcbiAgU2VydmljZUNvbnN1bWVyLFxuICBTZXJ2aWNlQ29udGV4dCxcbiAgdXNlU2VydmljZSxcbiAgd2l0aFNlcnZpY2VzLFxufSBmcm9tICcuL2NvbnRleHQuanMnO1xuXG5leHBvcnQgY29uc3QgU2tpcFByZXBhcmVUb2tlbiA9IGNyZWF0ZVRva2VuPGJvb2xlYW4+KCdTa2lwUHJlcGFyZVRva2VuJyk7XG5cbmV4cG9ydCB0eXBlIFJlbmRlciA9IChlbDogUmVhY3QuRWxlbWVudDwqPiwgY29udGV4dDogQ29udGV4dCkgPT4gYW55O1xuXG5kZWNsYXJlIHZhciBfX05PREVfXzogQm9vbGVhbjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIGV4dGVuZHMgRnVzaW9uQXBwIHtcbiAgY29uc3RydWN0b3Iocm9vdDogUmVhY3QuRWxlbWVudDwqPiwgcmVuZGVyOiA/UmVuZGVyKSB7XG4gICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW52YWxpZCBSZWFjdCBlbGVtZW50LiBFbnN1cmUgeW91ciByb290IGVsZW1lbnQgaXMgYSBSZWFjdC5FbGVtZW50IChlLmcuIDxGb28gLz4pIGFuZCBub3QgYSBSZWFjdC5Db21wb25lbnQgKGUuZy4gRm9vKSdcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGdldFNlcnZpY2UgPSAodG9rZW4pID0+IHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGNvbnN0IHByb3ZpZGVzID0gdGhpcy5nZXRTZXJ2aWNlKHRva2VuKTtcbiAgICAgIGNvbnN0IGlzUmVxdWlyZWRUb2tlbiA9IEJvb2xlYW4odG9rZW4ub3B0aW9uYWwpO1xuICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcyA9PT0gJ3VuZGVmaW5lZCcgJiYgaXNSZXF1aXJlZFRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVG9rZW4gJHt0b2tlbi5uYW1lfSBub3QgcmVnaXN0ZXJlZCBvciByZWdpc3RlcmVkIHBsdWdpbiBkb2VzIG5vdCBwcm92aWRlIGEgc2VydmljZS4gVG8gdXNlIGFuIG9wdGlvbmFsIHBsdWdpbiwgdXNlIFxcYFRva2VuLm9wdGlvbmFsXFxgLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm92aWRlcztcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlcmVyID0gY3JlYXRlUGx1Z2luKHtcbiAgICAgIGRlcHM6IHtcbiAgICAgICAgY3JpdGljYWxDaHVua0lkczogQ3JpdGljYWxDaHVua0lkc1Rva2VuLm9wdGlvbmFsLFxuICAgICAgICBza2lwUHJlcGFyZTogU2tpcFByZXBhcmVUb2tlbi5vcHRpb25hbCxcbiAgICAgICAgbG9nZ2VyOiBMb2dnZXJUb2tlbi5vcHRpb25hbCxcbiAgICAgIH0sXG4gICAgICBwcm92aWRlcyh7c2tpcFByZXBhcmUsIGxvZ2dlcn0pIHtcbiAgICAgICAgcmV0dXJuIChlbDogUmVhY3QuRWxlbWVudDwqPiwgY3R4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChza2lwUHJlcGFyZSA/IFByb21pc2UucmVzb2x2ZSgpIDogcHJlcGFyZShlbCwgY3R4KSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7fSkgLy8gcmVjb3ZlciBmcm9tIGZhaWxlZCBgcHJlcGFyZWBcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXIoZWwsIGN0eCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF9fTk9ERV9fKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZlclJlbmRlcihlbCwgbG9nZ2VyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UmVuZGVyKGVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbWlkZGxld2FyZSh7Y3JpdGljYWxDaHVua0lkc30pIHtcbiAgICAgICAgcmV0dXJuIChjdHgsIG5leHQpID0+IHtcbiAgICAgICAgICBpZiAoX19OT0RFX18gJiYgIWN0eC5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG1hcmtBc0NyaXRpY2FsID0gX19OT0RFX19cbiAgICAgICAgICAgID8gKGNodW5rSWQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQdXNoIHRvIGxlZ2FjeSBjb250ZXh0IGZvciBiYWNrd2FyZHMgY29tcGF0IHcvIGxlZ2FjeSBTU1IgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICBjdHgucHJlbG9hZENodW5rcy5wdXNoKGNodW5rSWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWxzbyB1c2UgbmV3IHNlcnZpY2UgaWYgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgICAgIGlmIChjcml0aWNhbENodW5rSWRzKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY2h1bmtJZHMgPSBjcml0aWNhbENodW5rSWRzLmZyb20oY3R4KTtcbiAgICAgICAgICAgICAgICAgIGNodW5rSWRzLmFkZChjaHVua0lkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbm9vcDtcblxuICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjb2xsZWN0IGFyYml0cmFyeSBtZXRhZGF0YSBkdXJpbmcgYSBnaXZlbiBTU1JcbiAgICAgICAgICAvLyBUaGUgcHJpbWFyeSB1c2UgY2FzZSBpcyB0byBjb2xsZWN0IGJ1bmRsZXItc3BlY2lmaWMgaW5mb3JtYXRpb25cbiAgICAgICAgICAvLyBhYm91dCBpbXBvcnQoKSBzdGF0ZW1lbnRzIGVuY291bnRlcmVkIGR1cmluZyBTU1Igc28gdGhhdCBhc3luY1xuICAgICAgICAgIC8vIGJ1bmRsZS1zcGxpdCBjbGllbnQgY29kZSBjYW4gYmUgcHJlbG9hZGVkL2ZldGNoZWQgYXBwcm9wcmlhdGVseVxuICAgICAgICAgIGN0eC5zc3JNZXRhZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnN0IHB1c2hTU1JNZXRhZGF0YSA9IF9fTk9ERV9fXG4gICAgICAgICAgICA/IChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5zc3JNZXRhZGF0YS5wdXNoKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBub29wO1xuXG4gICAgICAgICAgY3R4LmVsZW1lbnQgPSAoXG4gICAgICAgICAgICA8UHJlcGFyZVByb3ZpZGVyXG4gICAgICAgICAgICAgIG1hcmtBc0NyaXRpY2FsPXttYXJrQXNDcml0aWNhbH1cbiAgICAgICAgICAgICAgcHVzaFNTUk1ldGFkYXRhPXtwdXNoU1NSTWV0YWRhdGF9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxGdXNpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjdHh9PlxuICAgICAgICAgICAgICAgIDxTZXJ2aWNlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Z2V0U2VydmljZX0+XG4gICAgICAgICAgICAgICAgICB7Y3R4LmVsZW1lbnR9XG4gICAgICAgICAgICAgICAgPC9TZXJ2aWNlQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgPC9GdXNpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgPC9QcmVwYXJlUHJvdmlkZXI+XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9KTtcbiAgICBzdXBlcihyb290LCByZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgRnVzaW9uQ29udGV4dCxcbiAgUHJvdmlkZXJQbHVnaW4sXG4gIFByb3ZpZGVkSE9DLFxuICBQcm92aWRlcixcbiAgU2VydmljZUNvbnN1bWVyLFxuICBTZXJ2aWNlQ29udGV4dCxcbiAgdXNlU2VydmljZSxcbiAgd2l0aFNlcnZpY2VzLFxufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCAqIGZyb20gJy4vYXN5bmMvaW5kZXguanMnO1xuIl19