"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = withAsyncComponent;

var React = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _prepared = _interopRequireDefault(require("./prepared.js"));

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const contextTypes = {
  splitComponentLoaders: _propTypes.default.array.isRequired
};

if (false) {
  // $FlowFixMe
  contextTypes.markAsCritical = _propTypes.default.func; // $FlowFixMe

  contextTypes.pushSSRMetadata = _propTypes.default.func;
}

let cachedLoadedChunkIds;
let lastWebpackChunksLength;

function getLoadedChunkIds() {
  const webpackChunks = true ? window.webpackChunkFusion : [];

  if (cachedLoadedChunkIds && lastWebpackChunksLength === webpackChunks.length) {
    return cachedLoadedChunkIds;
  }

  cachedLoadedChunkIds = new Set(webpackChunks.flatMap(chunkTuple => chunkTuple[0]));
  lastWebpackChunksLength = webpackChunks.length;
  return cachedLoadedChunkIds;
}

function webpackChunksLoaded(chunkIds) {
  const loadedChunkIds = getLoadedChunkIds();
  return chunkIds.every(chunkId => loadedChunkIds.has(chunkId));
}

function withAsyncComponent({
  defer,
  load,
  LoadingComponent,
  ErrorComponent
}) {
  let AsyncComponent = null;
  let error = null; // This stores promise instrumentation used by webpack

  const metadata = {
    chunkIds: [],
    i18nKeys: []
  };
  let dynamicImportMetadata; // Stores promise instrumentation used by esbuild

  function WithAsyncComponent(props) {
    if (true) {
      // We need to check if the module is already loaded, as it could be marked as
      // critical during SSR. This is crucial in case the prepare ran during SSR,
      // but skipped on the client. In which case the AsyncComponent will never get
      // populated before app is hydrated, causing a rendering mismatch.
      if (!AsyncComponent) {
        let promise = load(); // $FlowFixMe

        const id = promise.__MODULE_ID; // $FlowFixMe

        const chunkIds = promise.__CHUNK_IDS;

        if (typeof __webpack_modules__ !== 'undefined' && __webpack_modules__[id] && webpackChunksLoaded(chunkIds)) {
          // If module is already loaded, it can be synchronously imported
          AsyncComponent = __webpack_require__(id).default;
        }
      }
    }

    if (error) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(LoadingComponent, {});
    }

    return /*#__PURE__*/(0, _jsxRuntime.jsx)(AsyncComponent, { ...props
    });
  }

  return (0, _prepared.default)((props, context) => {
    if (AsyncComponent) {
      if (false && context.markAsCritical) {
        metadata.chunkIds.forEach(chunkId => {
          context.markAsCritical(chunkId);
        });
      }

      if (false && context.pushSSRMetadata && dynamicImportMetadata) {
        context.pushSSRMetadata({
          type: 'critical-dynamic-import',
          data: dynamicImportMetadata
        });
      }

      if (process.env.NODE_ENV !== "production") {
        // In case promise instrumentation has changed, call
        // splitComponentLoaders again
        let componentPromise;

        try {
          componentPromise = load();
        } catch (e) {
          componentPromise = Promise.reject(e);
        } // $FlowFixMe


        metadata.chunkIds = componentPromise.__CHUNK_IDS || []; // $FlowFixMe

        metadata.i18nKeys = componentPromise.__I18N_KEYS || [];
        dynamicImportMetadata = // $FlowFixMe
        componentPromise.__FUSION_DYNAMIC_IMPORT_METADATA__;
        return Promise.all(context.splitComponentLoaders.map(loader => loader(metadata.chunkIds, metadata))).then(() => AsyncComponent);
      } else {
        return Promise.resolve(AsyncComponent);
      }
    }

    let componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    } // $FlowFixMe


    metadata.chunkIds = componentPromise.__CHUNK_IDS || []; // $FlowFixMe

    metadata.i18nKeys = componentPromise.__I18N_KEYS || [];
    dynamicImportMetadata = // $FlowFixMe
    componentPromise.__FUSION_DYNAMIC_IMPORT_METADATA__;

    if (false && context.markAsCritical) {
      // $FlowFixMe
      metadata.chunkIds.forEach(chunkId => {
        context.markAsCritical(chunkId);
      });
    }

    if (false && context.pushSSRMetadata && dynamicImportMetadata) {
      context.pushSSRMetadata({
        type: 'critical-dynamic-import',
        data: dynamicImportMetadata
      });
    }

    const loadPromises = [componentPromise, ...context.splitComponentLoaders.map(loader => loader(metadata.chunkIds, metadata))];
    return Promise.all(loadPromises).then(([asyncComponent]) => {
      // Note: .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;

      if (AsyncComponent === undefined) {
        throw new Error('Bundle does not contain a default export');
      }
    }).catch(err => {
      error = err;
      if (true) setTimeout(() => {
        throw err;
      }); // log error
    });
  }, {
    defer,
    contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hc3luYy9zcGxpdC5qcyJdLCJuYW1lcyI6WyJjb250ZXh0VHlwZXMiLCJzcGxpdENvbXBvbmVudExvYWRlcnMiLCJQcm9wVHlwZXMiLCJhcnJheSIsImlzUmVxdWlyZWQiLCJtYXJrQXNDcml0aWNhbCIsImZ1bmMiLCJwdXNoU1NSTWV0YWRhdGEiLCJjYWNoZWRMb2FkZWRDaHVua0lkcyIsImxhc3RXZWJwYWNrQ2h1bmtzTGVuZ3RoIiwiZ2V0TG9hZGVkQ2h1bmtJZHMiLCJ3ZWJwYWNrQ2h1bmtzIiwid2luZG93Iiwid2VicGFja0NodW5rRnVzaW9uIiwibGVuZ3RoIiwiU2V0IiwiZmxhdE1hcCIsImNodW5rVHVwbGUiLCJ3ZWJwYWNrQ2h1bmtzTG9hZGVkIiwiY2h1bmtJZHMiLCJsb2FkZWRDaHVua0lkcyIsImV2ZXJ5IiwiY2h1bmtJZCIsImhhcyIsIndpdGhBc3luY0NvbXBvbmVudCIsImRlZmVyIiwibG9hZCIsIkxvYWRpbmdDb21wb25lbnQiLCJFcnJvckNvbXBvbmVudCIsIkFzeW5jQ29tcG9uZW50IiwiZXJyb3IiLCJtZXRhZGF0YSIsImkxOG5LZXlzIiwiZHluYW1pY0ltcG9ydE1ldGFkYXRhIiwiV2l0aEFzeW5jQ29tcG9uZW50IiwicHJvcHMiLCJwcm9taXNlIiwiaWQiLCJfX01PRFVMRV9JRCIsIl9fQ0hVTktfSURTIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJkZWZhdWx0IiwiY29udGV4dCIsImZvckVhY2giLCJ0eXBlIiwiZGF0YSIsImNvbXBvbmVudFByb21pc2UiLCJlIiwiUHJvbWlzZSIsInJlamVjdCIsIl9fSTE4Tl9LRVlTIiwiX19GVVNJT05fRFlOQU1JQ19JTVBPUlRfTUVUQURBVEFfXyIsImFsbCIsIm1hcCIsImxvYWRlciIsInRoZW4iLCJyZXNvbHZlIiwibG9hZFByb21pc2VzIiwiYXN5bmNDb21wb25lbnQiLCJ1bmRlZmluZWQiLCJFcnJvciIsImNhdGNoIiwiZXJyIiwic2V0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QUFNLENBQUN4QixRQUFRLENBQUNaLFFBQVYsRUFBb0JZLFFBQXBCLENBREwsQ0FGZ0IsQ0FBckI7QUFPQSxXQUFPa0IsT0FBTyxDQUFDSSxHQUFSLENBQVlLLFlBQVosRUFDSkYsSUFESSxDQUNDLENBQUMsQ0FBQ0csY0FBRCxDQUFELEtBQXNCO0FBQzFCO0FBQ0E5QixNQUFBQSxjQUFjLEdBQUc4QixjQUFjLENBQUNqQixPQUFoQzs7QUFDQSxVQUFJYixjQUFjLEtBQUsrQixTQUF2QixFQUFrQztBQUNoQyxjQUFNLElBQUlDLEtBQUosQ0FBVSwwQ0FBVixDQUFOO0FBQ0Q7QUFDRixLQVBJLEVBUUpDLEtBUkksQ0FRR0MsR0FBRCxJQUFTO0FBQ2RqQyxNQUFBQSxLQUFLLEdBQUdpQyxHQUFSO0FBQ0EsZ0JBQ0VDLFVBQVUsQ0FBQyxNQUFNO0FBQ2YsY0FBTUQsR0FBTjtBQUNELE9BRlMsQ0FBVixDQUhZLENBS1I7QUFDUCxLQWRJLENBQVA7QUFlRCxHQTdGSSxFQThGTDtBQUFDdEMsSUFBQUEsS0FBRDtBQUFRekIsSUFBQUEsWUFBUjtBQUFzQmlFLElBQUFBLFdBQVcsRUFBRTtBQUFuQyxHQTlGSyxFQStGTC9CLGtCQS9GSyxDQUFQO0FBZ0dEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIENvcHlyaWdodCAoYykgMjAxOCBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBwcmVwYXJlZCBmcm9tICcuL3ByZXBhcmVkLmpzJztcblxuZGVjbGFyZSB2YXIgX193ZWJwYWNrX21vZHVsZXNfXzoge1tzdHJpbmddOiBhbnl9O1xuZGVjbGFyZSB2YXIgX193ZWJwYWNrX3JlcXVpcmVfXzogKGFueSkgPT4gYW55O1xuXG5jb25zdCBjb250ZXh0VHlwZXMgPSB7XG4gIHNwbGl0Q29tcG9uZW50TG9hZGVyczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG59O1xuXG5pZiAoX19OT0RFX18pIHtcbiAgLy8gJEZsb3dGaXhNZVxuICBjb250ZXh0VHlwZXMubWFya0FzQ3JpdGljYWwgPSBQcm9wVHlwZXMuZnVuYztcbiAgLy8gJEZsb3dGaXhNZVxuICBjb250ZXh0VHlwZXMucHVzaFNTUk1ldGFkYXRhID0gUHJvcFR5cGVzLmZ1bmM7XG59XG5cbmxldCBjYWNoZWRMb2FkZWRDaHVua0lkcztcbmxldCBsYXN0V2VicGFja0NodW5rc0xlbmd0aDtcbmZ1bmN0aW9uIGdldExvYWRlZENodW5rSWRzKCkge1xuICBjb25zdCB3ZWJwYWNrQ2h1bmtzID0gX19CUk9XU0VSX18gPyB3aW5kb3cud2VicGFja0NodW5rRnVzaW9uIDogW107XG5cbiAgaWYgKFxuICAgIGNhY2hlZExvYWRlZENodW5rSWRzICYmXG4gICAgbGFzdFdlYnBhY2tDaHVua3NMZW5ndGggPT09IHdlYnBhY2tDaHVua3MubGVuZ3RoXG4gICkge1xuICAgIHJldHVybiBjYWNoZWRMb2FkZWRDaHVua0lkcztcbiAgfVxuXG4gIGNhY2hlZExvYWRlZENodW5rSWRzID0gbmV3IFNldChcbiAgICB3ZWJwYWNrQ2h1bmtzLmZsYXRNYXAoKGNodW5rVHVwbGUpID0+IGNodW5rVHVwbGVbMF0pXG4gICk7XG4gIGxhc3RXZWJwYWNrQ2h1bmtzTGVuZ3RoID0gd2VicGFja0NodW5rcy5sZW5ndGg7XG5cbiAgcmV0dXJuIGNhY2hlZExvYWRlZENodW5rSWRzO1xufVxuXG5mdW5jdGlvbiB3ZWJwYWNrQ2h1bmtzTG9hZGVkKGNodW5rSWRzKSB7XG4gIGNvbnN0IGxvYWRlZENodW5rSWRzID0gZ2V0TG9hZGVkQ2h1bmtJZHMoKTtcblxuICByZXR1cm4gY2h1bmtJZHMuZXZlcnkoKGNodW5rSWQpID0+IGxvYWRlZENodW5rSWRzLmhhcyhjaHVua0lkKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhBc3luY0NvbXBvbmVudDxDb25maWc+KHtcbiAgZGVmZXIsXG4gIGxvYWQsXG4gIExvYWRpbmdDb21wb25lbnQsXG4gIEVycm9yQ29tcG9uZW50LFxufToge1xuICBkZWZlcj86IGJvb2xlYW4sXG4gIGxvYWQ6ICgpID0+IFByb21pc2U8e2RlZmF1bHQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8Q29uZmlnPn0+LFxuICBMb2FkaW5nQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4sXG4gIEVycm9yQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4sXG59KTogUmVhY3QuQ29tcG9uZW50VHlwZTxDb25maWc+IHtcbiAgbGV0IEFzeW5jQ29tcG9uZW50ID0gbnVsbDtcbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgLy8gVGhpcyBzdG9yZXMgcHJvbWlzZSBpbnN0cnVtZW50YXRpb24gdXNlZCBieSB3ZWJwYWNrXG4gIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgIGNodW5rSWRzOiBbXSxcbiAgICBpMThuS2V5czogW10sXG4gIH07XG4gIGxldCBkeW5hbWljSW1wb3J0TWV0YWRhdGE7IC8vIFN0b3JlcyBwcm9taXNlIGluc3RydW1lbnRhdGlvbiB1c2VkIGJ5IGVzYnVpbGRcblxuICBmdW5jdGlvbiBXaXRoQXN5bmNDb21wb25lbnQocHJvcHMpIHtcbiAgICBpZiAoX19CUk9XU0VSX18pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG1vZHVsZSBpcyBhbHJlYWR5IGxvYWRlZCwgYXMgaXQgY291bGQgYmUgbWFya2VkIGFzXG4gICAgICAvLyBjcml0aWNhbCBkdXJpbmcgU1NSLiBUaGlzIGlzIGNydWNpYWwgaW4gY2FzZSB0aGUgcHJlcGFyZSByYW4gZHVyaW5nIFNTUixcbiAgICAgIC8vIGJ1dCBza2lwcGVkIG9uIHRoZSBjbGllbnQuIEluIHdoaWNoIGNhc2UgdGhlIEFzeW5jQ29tcG9uZW50IHdpbGwgbmV2ZXIgZ2V0XG4gICAgICAvLyBwb3B1bGF0ZWQgYmVmb3JlIGFwcCBpcyBoeWRyYXRlZCwgY2F1c2luZyBhIHJlbmRlcmluZyBtaXNtYXRjaC5cbiAgICAgIGlmICghQXN5bmNDb21wb25lbnQpIHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBsb2FkKCk7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgY29uc3QgaWQgPSBwcm9taXNlLl9fTU9EVUxFX0lEO1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIGNvbnN0IGNodW5rSWRzID0gcHJvbWlzZS5fX0NIVU5LX0lEUztcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIF9fd2VicGFja19tb2R1bGVzX18gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgX193ZWJwYWNrX21vZHVsZXNfX1tpZF0gJiZcbiAgICAgICAgICB3ZWJwYWNrQ2h1bmtzTG9hZGVkKGNodW5rSWRzKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBJZiBtb2R1bGUgaXMgYWxyZWFkeSBsb2FkZWQsIGl0IGNhbiBiZSBzeW5jaHJvbm91c2x5IGltcG9ydGVkXG4gICAgICAgICAgQXN5bmNDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKS5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gPEVycm9yQ29tcG9uZW50IGVycm9yPXtlcnJvcn0gLz47XG4gICAgfVxuICAgIGlmICghQXN5bmNDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiA8TG9hZGluZ0NvbXBvbmVudCAvPjtcbiAgICB9XG4gICAgcmV0dXJuIDxBc3luY0NvbXBvbmVudCB7Li4ucHJvcHN9IC8+O1xuICB9XG5cbiAgcmV0dXJuIHByZXBhcmVkKFxuICAgIChwcm9wcywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKEFzeW5jQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChfX05PREVfXyAmJiBjb250ZXh0Lm1hcmtBc0NyaXRpY2FsKSB7XG4gICAgICAgICAgbWV0YWRhdGEuY2h1bmtJZHMuZm9yRWFjaCgoY2h1bmtJZCkgPT4ge1xuICAgICAgICAgICAgY29udGV4dC5tYXJrQXNDcml0aWNhbChjaHVua0lkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfX05PREVfXyAmJiBjb250ZXh0LnB1c2hTU1JNZXRhZGF0YSAmJiBkeW5hbWljSW1wb3J0TWV0YWRhdGEpIHtcbiAgICAgICAgICBjb250ZXh0LnB1c2hTU1JNZXRhZGF0YSh7XG4gICAgICAgICAgICB0eXBlOiAnY3JpdGljYWwtZHluYW1pYy1pbXBvcnQnLFxuICAgICAgICAgICAgZGF0YTogZHluYW1pY0ltcG9ydE1ldGFkYXRhLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAvLyBJbiBjYXNlIHByb21pc2UgaW5zdHJ1bWVudGF0aW9uIGhhcyBjaGFuZ2VkLCBjYWxsXG4gICAgICAgICAgLy8gc3BsaXRDb21wb25lbnRMb2FkZXJzIGFnYWluXG4gICAgICAgICAgbGV0IGNvbXBvbmVudFByb21pc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBvbmVudFByb21pc2UgPSBsb2FkKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29tcG9uZW50UHJvbWlzZSA9IChQcm9taXNlLnJlamVjdChlKTogYW55KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgIG1ldGFkYXRhLmNodW5rSWRzID0gY29tcG9uZW50UHJvbWlzZS5fX0NIVU5LX0lEUyB8fCBbXTtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgbWV0YWRhdGEuaTE4bktleXMgPSBjb21wb25lbnRQcm9taXNlLl9fSTE4Tl9LRVlTIHx8IFtdO1xuICAgICAgICAgIGR5bmFtaWNJbXBvcnRNZXRhZGF0YSA9XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgICBjb21wb25lbnRQcm9taXNlLl9fRlVTSU9OX0RZTkFNSUNfSU1QT1JUX01FVEFEQVRBX187XG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjb250ZXh0LnNwbGl0Q29tcG9uZW50TG9hZGVycy5tYXAoKGxvYWRlcikgPT5cbiAgICAgICAgICAgICAgbG9hZGVyKG1ldGFkYXRhLmNodW5rSWRzLCBtZXRhZGF0YSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLnRoZW4oKCkgPT4gQXN5bmNDb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoQXN5bmNDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBjb21wb25lbnRQcm9taXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tcG9uZW50UHJvbWlzZSA9IGxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29tcG9uZW50UHJvbWlzZSA9IChQcm9taXNlLnJlamVjdChlKTogYW55KTtcbiAgICAgIH1cblxuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgbWV0YWRhdGEuY2h1bmtJZHMgPSBjb21wb25lbnRQcm9taXNlLl9fQ0hVTktfSURTIHx8IFtdO1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgbWV0YWRhdGEuaTE4bktleXMgPSBjb21wb25lbnRQcm9taXNlLl9fSTE4Tl9LRVlTIHx8IFtdO1xuICAgICAgZHluYW1pY0ltcG9ydE1ldGFkYXRhID1cbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBjb21wb25lbnRQcm9taXNlLl9fRlVTSU9OX0RZTkFNSUNfSU1QT1JUX01FVEFEQVRBX187XG4gICAgICBpZiAoX19OT0RFX18gJiYgY29udGV4dC5tYXJrQXNDcml0aWNhbCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG1ldGFkYXRhLmNodW5rSWRzLmZvckVhY2goKGNodW5rSWQpID0+IHtcbiAgICAgICAgICBjb250ZXh0Lm1hcmtBc0NyaXRpY2FsKGNodW5rSWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9fTk9ERV9fICYmIGNvbnRleHQucHVzaFNTUk1ldGFkYXRhICYmIGR5bmFtaWNJbXBvcnRNZXRhZGF0YSkge1xuICAgICAgICBjb250ZXh0LnB1c2hTU1JNZXRhZGF0YSh7XG4gICAgICAgICAgdHlwZTogJ2NyaXRpY2FsLWR5bmFtaWMtaW1wb3J0JyxcbiAgICAgICAgICBkYXRhOiBkeW5hbWljSW1wb3J0TWV0YWRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkUHJvbWlzZXMgPSBbXG4gICAgICAgIGNvbXBvbmVudFByb21pc2UsXG4gICAgICAgIC4uLmNvbnRleHQuc3BsaXRDb21wb25lbnRMb2FkZXJzLm1hcCgobG9hZGVyKSA9PlxuICAgICAgICAgIGxvYWRlcihtZXRhZGF0YS5jaHVua0lkcywgbWV0YWRhdGEpXG4gICAgICAgICksXG4gICAgICBdO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZFByb21pc2VzKVxuICAgICAgICAudGhlbigoW2FzeW5jQ29tcG9uZW50XSkgPT4ge1xuICAgICAgICAgIC8vIE5vdGU6IC5kZWZhdWx0IGlzIHRvb2xjaGFpbiBzcGVjaWZpYywgYnJlYWtzIHcvIENvbW1vbkpTIGV4cG9ydHNcbiAgICAgICAgICBBc3luY0NvbXBvbmVudCA9IGFzeW5jQ29tcG9uZW50LmRlZmF1bHQ7XG4gICAgICAgICAgaWYgKEFzeW5jQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnVuZGxlIGRvZXMgbm90IGNvbnRhaW4gYSBkZWZhdWx0IGV4cG9ydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICBpZiAoX19CUk9XU0VSX18pXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7IC8vIGxvZyBlcnJvclxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHtkZWZlciwgY29udGV4dFR5cGVzLCBmb3JjZVVwZGF0ZTogdHJ1ZX1cbiAgKShXaXRoQXN5bmNDb21wb25lbnQpO1xufVxuIl19