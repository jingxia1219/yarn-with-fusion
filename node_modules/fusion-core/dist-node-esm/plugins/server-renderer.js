/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
import { now } from '../utils/now.js';
export default function createServerRenderPlugin(app) {
  return function serverRenderPlugin({
    render,
    timing
  }) {
    return async function renderer(ctx, next) {
      app._setRef();

      app.renderSetupCtx = ctx; // Element wrappers should be added in *reverse* topological order so that
      // the resulting element tree is in topological order during renders.
      // For example, if plugin B depends on plugin A, the tree should be:
      // <AProvider>
      //   <BProvider>{root}</BProvider>
      // </APRovider>
      // In this case, B provider can depend on the context of A provider.

      for (var i = app.renderSetup.length - 1; i >= 0; i--) {
        const wrapper = app.renderSetup[i];
        const result = wrapper(ctx.element);

        if (result !== void 0) {
          ctx.element = result;
        }
      }

      app.renderSetupCtx = void 0;

      app._clearRef();

      const timer = timing.from(ctx);
      timer.downstream.resolve(now() - timer.start);
      let renderTime = null;

      if (ctx.element && !ctx.body && ctx.respond !== false) {
        const renderStart = now();
        ctx.rendered = await render(ctx.element, ctx);
        renderTime = now() - renderStart;
      }

      app._setRef();

      app.SSREffectCtx = ctx;

      for (const effect of ctx.postRenderEffects) {
        effect();
      }

      app.SSREffectCtx = void 0;

      app._clearRef();

      timer.upstreamStart = now();
      await next();

      if (ctx.element && typeof renderTime === 'number') {
        timer.render.resolve(renderTime);
      }
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9wbHVnaW5zL3NlcnZlci1yZW5kZXJlci5qcyJdLCJuYW1lcyI6WyJub3ciLCJjcmVhdGVTZXJ2ZXJSZW5kZXJQbHVnaW4iLCJhcHAiLCJzZXJ2ZXJSZW5kZXJQbHVnaW4iLCJyZW5kZXIiLCJ0aW1pbmciLCJyZW5kZXJlciIsImN0eCIsIm5leHQiLCJfc2V0UmVmIiwicmVuZGVyU2V0dXBDdHgiLCJpIiwicmVuZGVyU2V0dXAiLCJsZW5ndGgiLCJ3cmFwcGVyIiwicmVzdWx0IiwiZWxlbWVudCIsIl9jbGVhclJlZiIsInRpbWVyIiwiZnJvbSIsImRvd25zdHJlYW0iLCJyZXNvbHZlIiwic3RhcnQiLCJyZW5kZXJUaW1lIiwiYm9keSIsInJlc3BvbmQiLCJyZW5kZXJTdGFydCIsInJlbmRlcmVkIiwiU1NSRWZmZWN0Q3R4IiwiZWZmZWN0IiwicG9zdFJlbmRlckVmZmVjdHMiLCJ1cHN0cmVhbVN0YXJ0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLFNBQVFBLEdBQVIsUUFBa0IsaUJBQWxCO0FBRUEsZUFBZSxTQUFTQyx3QkFBVCxDQUFrQ0MsR0FBbEMsRUFBdUM7QUFDcEQsU0FBTyxTQUFTQyxrQkFBVCxDQUE0QjtBQUFDQyxJQUFBQSxNQUFEO0FBQVNDLElBQUFBO0FBQVQsR0FBNUIsRUFBOEM7QUFDbkQsV0FBTyxlQUFlQyxRQUFmLENBQXdCQyxHQUF4QixFQUE2QkMsSUFBN0IsRUFBbUM7QUFDeENOLE1BQUFBLEdBQUcsQ0FBQ08sT0FBSjs7QUFDQVAsTUFBQUEsR0FBRyxDQUFDUSxjQUFKLEdBQXFCSCxHQUFyQixDQUZ3QyxDQUd4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxXQUFLLElBQUlJLENBQUMsR0FBR1QsR0FBRyxDQUFDVSxXQUFKLENBQWdCQyxNQUFoQixHQUF5QixDQUF0QyxFQUF5Q0YsQ0FBQyxJQUFJLENBQTlDLEVBQWlEQSxDQUFDLEVBQWxELEVBQXNEO0FBQ3BELGNBQU1HLE9BQU8sR0FBR1osR0FBRyxDQUFDVSxXQUFKLENBQWdCRCxDQUFoQixDQUFoQjtBQUNBLGNBQU1JLE1BQU0sR0FBR0QsT0FBTyxDQUFDUCxHQUFHLENBQUNTLE9BQUwsQ0FBdEI7O0FBQ0EsWUFBSUQsTUFBTSxLQUFLLEtBQUssQ0FBcEIsRUFBdUI7QUFDckJSLFVBQUFBLEdBQUcsQ0FBQ1MsT0FBSixHQUFjRCxNQUFkO0FBQ0Q7QUFDRjs7QUFDRGIsTUFBQUEsR0FBRyxDQUFDUSxjQUFKLEdBQXFCLEtBQUssQ0FBMUI7O0FBQ0FSLE1BQUFBLEdBQUcsQ0FBQ2UsU0FBSjs7QUFFQSxZQUFNQyxLQUFLLEdBQUdiLE1BQU0sQ0FBQ2MsSUFBUCxDQUFZWixHQUFaLENBQWQ7QUFDQVcsTUFBQUEsS0FBSyxDQUFDRSxVQUFOLENBQWlCQyxPQUFqQixDQUF5QnJCLEdBQUcsS0FBS2tCLEtBQUssQ0FBQ0ksS0FBdkM7QUFFQSxVQUFJQyxVQUFVLEdBQUcsSUFBakI7O0FBQ0EsVUFBSWhCLEdBQUcsQ0FBQ1MsT0FBSixJQUFlLENBQUNULEdBQUcsQ0FBQ2lCLElBQXBCLElBQTRCakIsR0FBRyxDQUFDa0IsT0FBSixLQUFnQixLQUFoRCxFQUF1RDtBQUNyRCxjQUFNQyxXQUFXLEdBQUcxQixHQUFHLEVBQXZCO0FBQ0FPLFFBQUFBLEdBQUcsQ0FBQ29CLFFBQUosR0FBZSxNQUFNdkIsTUFBTSxDQUFDRyxHQUFHLENBQUNTLE9BQUwsRUFBY1QsR0FBZCxDQUEzQjtBQUNBZ0IsUUFBQUEsVUFBVSxHQUFHdkIsR0FBRyxLQUFLMEIsV0FBckI7QUFDRDs7QUFFRHhCLE1BQUFBLEdBQUcsQ0FBQ08sT0FBSjs7QUFDQVAsTUFBQUEsR0FBRyxDQUFDMEIsWUFBSixHQUFtQnJCLEdBQW5COztBQUNBLFdBQUssTUFBTXNCLE1BQVgsSUFBcUJ0QixHQUFHLENBQUN1QixpQkFBekIsRUFBNEM7QUFDMUNELFFBQUFBLE1BQU07QUFDUDs7QUFDRDNCLE1BQUFBLEdBQUcsQ0FBQzBCLFlBQUosR0FBbUIsS0FBSyxDQUF4Qjs7QUFDQTFCLE1BQUFBLEdBQUcsQ0FBQ2UsU0FBSjs7QUFFQUMsTUFBQUEsS0FBSyxDQUFDYSxhQUFOLEdBQXNCL0IsR0FBRyxFQUF6QjtBQUNBLFlBQU1RLElBQUksRUFBVjs7QUFFQSxVQUFJRCxHQUFHLENBQUNTLE9BQUosSUFBZSxPQUFPTyxVQUFQLEtBQXNCLFFBQXpDLEVBQW1EO0FBQ2pETCxRQUFBQSxLQUFLLENBQUNkLE1BQU4sQ0FBYWlCLE9BQWIsQ0FBcUJFLFVBQXJCO0FBQ0Q7QUFDRixLQTVDRDtBQTZDRCxHQTlDRDtBQStDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBDb3B5cmlnaHQgKGMpIDIwMTggVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbm9mbG93XG4gKi9cblxuaW1wb3J0IHtub3d9IGZyb20gJy4uL3V0aWxzL25vdy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlclJlbmRlclBsdWdpbihhcHApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlcnZlclJlbmRlclBsdWdpbih7cmVuZGVyLCB0aW1pbmd9KSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHJlbmRlcmVyKGN0eCwgbmV4dCkge1xuICAgICAgYXBwLl9zZXRSZWYoKTtcbiAgICAgIGFwcC5yZW5kZXJTZXR1cEN0eCA9IGN0eDtcbiAgICAgIC8vIEVsZW1lbnQgd3JhcHBlcnMgc2hvdWxkIGJlIGFkZGVkIGluICpyZXZlcnNlKiB0b3BvbG9naWNhbCBvcmRlciBzbyB0aGF0XG4gICAgICAvLyB0aGUgcmVzdWx0aW5nIGVsZW1lbnQgdHJlZSBpcyBpbiB0b3BvbG9naWNhbCBvcmRlciBkdXJpbmcgcmVuZGVycy5cbiAgICAgIC8vIEZvciBleGFtcGxlLCBpZiBwbHVnaW4gQiBkZXBlbmRzIG9uIHBsdWdpbiBBLCB0aGUgdHJlZSBzaG91bGQgYmU6XG4gICAgICAvLyA8QVByb3ZpZGVyPlxuICAgICAgLy8gICA8QlByb3ZpZGVyPntyb290fTwvQlByb3ZpZGVyPlxuICAgICAgLy8gPC9BUFJvdmlkZXI+XG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIEIgcHJvdmlkZXIgY2FuIGRlcGVuZCBvbiB0aGUgY29udGV4dCBvZiBBIHByb3ZpZGVyLlxuICAgICAgZm9yICh2YXIgaSA9IGFwcC5yZW5kZXJTZXR1cC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gYXBwLnJlbmRlclNldHVwW2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB3cmFwcGVyKGN0eC5lbGVtZW50KTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY3R4LmVsZW1lbnQgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcC5yZW5kZXJTZXR1cEN0eCA9IHZvaWQgMDtcbiAgICAgIGFwcC5fY2xlYXJSZWYoKTtcblxuICAgICAgY29uc3QgdGltZXIgPSB0aW1pbmcuZnJvbShjdHgpO1xuICAgICAgdGltZXIuZG93bnN0cmVhbS5yZXNvbHZlKG5vdygpIC0gdGltZXIuc3RhcnQpO1xuXG4gICAgICBsZXQgcmVuZGVyVGltZSA9IG51bGw7XG4gICAgICBpZiAoY3R4LmVsZW1lbnQgJiYgIWN0eC5ib2R5ICYmIGN0eC5yZXNwb25kICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCByZW5kZXJTdGFydCA9IG5vdygpO1xuICAgICAgICBjdHgucmVuZGVyZWQgPSBhd2FpdCByZW5kZXIoY3R4LmVsZW1lbnQsIGN0eCk7XG4gICAgICAgIHJlbmRlclRpbWUgPSBub3coKSAtIHJlbmRlclN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBhcHAuX3NldFJlZigpO1xuICAgICAgYXBwLlNTUkVmZmVjdEN0eCA9IGN0eDtcbiAgICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGN0eC5wb3N0UmVuZGVyRWZmZWN0cykge1xuICAgICAgICBlZmZlY3QoKTtcbiAgICAgIH1cbiAgICAgIGFwcC5TU1JFZmZlY3RDdHggPSB2b2lkIDA7XG4gICAgICBhcHAuX2NsZWFyUmVmKCk7XG5cbiAgICAgIHRpbWVyLnVwc3RyZWFtU3RhcnQgPSBub3coKTtcbiAgICAgIGF3YWl0IG5leHQoKTtcblxuICAgICAgaWYgKGN0eC5lbGVtZW50ICYmIHR5cGVvZiByZW5kZXJUaW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aW1lci5yZW5kZXIucmVzb2x2ZShyZW5kZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuIl19