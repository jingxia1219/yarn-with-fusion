/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-disable require-yield */
import { createPlugin, declarePlugin, getPluginFn } from './create-plugin';
import { createToken, getTokenRef, TokenImpl } from './create-token';
import { ElementToken, RenderToken, SSRDeciderToken, RouteTagsToken, EnableMiddlewareTimingToken } from './tokens';
import { SSRDecider } from './plugins/ssr';
import RouteTagsPlugin from './plugins/route-tags';
import { captureStackTrace, DIError } from './stack-trace.js';
import { App as Core, getResolvedDep } from './core.js';
import { sortLegacy } from './legacy-compat.js';

class BaseApp extends Core {
  constructor(el, render) {
    super();
    this.registered = new Map(); // getTokenRef(token) -> {value, aliases, enhancers}

    this.plugins = []; // Token

    el && this.register(ElementToken, el);

    if (render) {
      this.renderer = render;
    }

    this.register(SSRDeciderToken, SSRDecider);
    this.register(RouteTagsToken, RouteTagsPlugin);
    this.done = false;
  }

  register(tokenOrValue, maybeValue) {
    const hasToken = tokenOrValue instanceof TokenImpl;
    const token = hasToken ? tokenOrValue : createToken('UnnamedPlugin');
    const value = hasToken ? maybeValue : tokenOrValue;

    if (!hasToken && (value == null || !getPluginFn(value))) {
      throw new DIError({
        message: process.env.NODE_ENV !== "production" ? `Cannot register ${String(tokenOrValue)} without a token. Did you accidentally register a ${false ? 'browser' : 'server'} plugin on the ${false ? 'server' : 'browser'}?` : 'Invalid configuration registration',
        errorDoc: 'value-without-token',
        caller: this.register
      });
    } // the renderer is a special case, since it needs to be always run last


    if (token === RenderToken) {
      this.renderer = value;

      const alias = () => {
        throw new DIError({
          message: 'Aliasing for RenderToken not supported',
          caller: alias
        });
      };

      return {
        alias
      };
    }

    token.stacks.push({
      type: 'register',
      stack: captureStackTrace(this.register)
    });

    if (value && value.__plugin__) {
      token.stacks.push({
        type: 'plugin',
        stack: value.stack
      });
    }

    return this._register(token, value);
  }

  _register(token, value) {
    const foundPluginFn = getPluginFn(value); // const registerResult = super.registerPlugin(token, value);

    const registerResult = super.registerPlugin(token, foundPluginFn ? foundPluginFn : declarePlugin(function* () {
      return value;
    })); // getPluginFn(valaue)
    //   ? super.registerPlugin(token, value.__fn__)
    //   : super.registerPlugin(
    //       token,
    //       declarePlugin(function* () {
    //         return value;
    //       })
    //     );
    // For introspect plugin

    const {
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: []
    };
    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });

    const alias = (sourceToken, destToken) => {
      registerResult.alias(sourceToken, destToken);
      const stack = captureStackTrace(alias);
      sourceToken.stacks.push({
        type: 'alias-from',
        stack
      });
      destToken.stacks.push({
        type: 'alias-to',
        stack
      });
      return {
        alias
      };
    };

    return {
      alias
    };
  }

  middleware(deps, middleware) {
    if (middleware === undefined) {
      middleware = () => deps;
    }

    this.register(createPlugin({
      deps: deps,
      middleware
    }));
  }

  enhance(token, enhancer) {
    token.stacks.push({
      type: 'enhance',
      stack: captureStackTrace(this.enhance)
    }); // For introspect plugin

    const {
      value,
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: [],
      value: undefined
    };

    if (enhancers && Array.isArray(enhancers)) {
      enhancers.push(enhancer);
    }

    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });
    return super.enhance(token, enhancer);
  }

  cleanup() {
    return Promise.all(this.cleanups.map(fn => fn()));
  }

  resolve() {
    if (!this.renderer) {
      throw new Error('Missing registration for RenderToken');
    }

    this._register(RenderToken, this.renderer);

    if (this.registeredTokens.has(getTokenRef(EnableMiddlewareTimingToken))) {
      this.enableMiddlewareTiming = true;
    } // Note that core init actually returns a promise.
    // However, core init will synchronously complete as long as there is no
    // async tasks. The only planned async hook is withStartup(), which is not
    // currently implemented. Introducing async startup is technically a
    // breaking change, which we are avoiding initially. When we want to make
    // this breaking change and introduce withStartup(), we should add an await
    // to the statement below


    super.init();
    sortLegacy(this); // Preserve legacy order for compatibility

    this.done = true;
  }

  getService(token) {
    if (!this.done) {
      throw new DIError({
        message: 'Cannot get service from unresolved app',
        caller: this.getService
      });
    }

    const result = getResolvedDep(this, token);

    if (result.resolved) {
      return result.value;
    }
  }

  callback() {}

}

export default BaseApp;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9iYXNlLWFwcC5qcyJdLCJuYW1lcyI6WyJjcmVhdGVQbHVnaW4iLCJkZWNsYXJlUGx1Z2luIiwiZ2V0UGx1Z2luRm4iLCJjcmVhdGVUb2tlbiIsImdldFRva2VuUmVmIiwiVG9rZW5JbXBsIiwiRWxlbWVudFRva2VuIiwiUmVuZGVyVG9rZW4iLCJTU1JEZWNpZGVyVG9rZW4iLCJSb3V0ZVRhZ3NUb2tlbiIsIkVuYWJsZU1pZGRsZXdhcmVUaW1pbmdUb2tlbiIsIlNTUkRlY2lkZXIiLCJSb3V0ZVRhZ3NQbHVnaW4iLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkRJRXJyb3IiLCJBcHAiLCJDb3JlIiwiZ2V0UmVzb2x2ZWREZXAiLCJzb3J0TGVnYWN5IiwiQmFzZUFwcCIsImNvbnN0cnVjdG9yIiwiZWwiLCJyZW5kZXIiLCJyZWdpc3RlcmVkIiwiTWFwIiwicGx1Z2lucyIsInJlZ2lzdGVyIiwicmVuZGVyZXIiLCJkb25lIiwidG9rZW5PclZhbHVlIiwibWF5YmVWYWx1ZSIsImhhc1Rva2VuIiwidG9rZW4iLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJTdHJpbmciLCJlcnJvckRvYyIsImNhbGxlciIsImFsaWFzIiwic3RhY2tzIiwicHVzaCIsInR5cGUiLCJzdGFjayIsIl9fcGx1Z2luX18iLCJfcmVnaXN0ZXIiLCJmb3VuZFBsdWdpbkZuIiwicmVnaXN0ZXJSZXN1bHQiLCJyZWdpc3RlclBsdWdpbiIsImFsaWFzZXMiLCJlbmhhbmNlcnMiLCJnZXQiLCJzZXQiLCJzb3VyY2VUb2tlbiIsImRlc3RUb2tlbiIsIm1pZGRsZXdhcmUiLCJkZXBzIiwidW5kZWZpbmVkIiwiZW5oYW5jZSIsImVuaGFuY2VyIiwiQXJyYXkiLCJpc0FycmF5IiwiY2xlYW51cCIsIlByb21pc2UiLCJhbGwiLCJjbGVhbnVwcyIsIm1hcCIsImZuIiwicmVzb2x2ZSIsIkVycm9yIiwicmVnaXN0ZXJlZFRva2VucyIsImhhcyIsImVuYWJsZU1pZGRsZXdhcmVUaW1pbmciLCJpbml0IiwiZ2V0U2Vy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LFVBQVUsQ0FBQyxJQUFELENBQVYsQ0FuQlEsQ0FtQlU7O0FBRWxCLFNBQUtVLElBQUwsR0FBWSxJQUFaO0FBQ0Q7O0FBRUQ2QyxFQUFBQSxVQUFVLENBQUN6QyxLQUFELEVBQVE7QUFDaEIsUUFBSSxDQUFDLEtBQUtKLElBQVYsRUFBZ0I7QUFDZCxZQUFNLElBQUlkLE9BQUosQ0FBWTtBQUNoQm9CLFFBQUFBLE9BQU8sRUFBRSx3Q0FETztBQUVoQkcsUUFBQUEsTUFBTSxFQUFFLEtBQUtvQztBQUZHLE9BQVosQ0FBTjtBQUlEOztBQUNELFVBQU1DLE1BQU0sR0FBR3pELGNBQWMsQ0FBQyxJQUFELEVBQU9lLEtBQVAsQ0FBN0I7O0FBQ0EsUUFBSTBDLE1BQU0sQ0FBQ0MsUUFBWCxFQUFxQjtBQUNuQixhQUFPRCxNQUFNLENBQUN6QyxLQUFkO0FBQ0Q7QUFDRjs7QUFFRDJDLEVBQUFBLFFBQVEsR0FBRyxDQUFFOztBQTdLWTs7QUFnTDNCLGVBQWV6RCxPQUFmIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIENvcHlyaWdodCAoYykgMjAxOCBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBub2Zsb3dcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLXlpZWxkICovXG5pbXBvcnQge2NyZWF0ZVBsdWdpbiwgZGVjbGFyZVBsdWdpbiwgZ2V0UGx1Z2luRm59IGZyb20gJy4vY3JlYXRlLXBsdWdpbic7XG5pbXBvcnQge2NyZWF0ZVRva2VuLCBnZXRUb2tlblJlZiwgVG9rZW5JbXBsfSBmcm9tICcuL2NyZWF0ZS10b2tlbic7XG5pbXBvcnQge1xuICBFbGVtZW50VG9rZW4sXG4gIFJlbmRlclRva2VuLFxuICBTU1JEZWNpZGVyVG9rZW4sXG4gIFJvdXRlVGFnc1Rva2VuLFxuICBFbmFibGVNaWRkbGV3YXJlVGltaW5nVG9rZW4sXG59IGZyb20gJy4vdG9rZW5zJztcbmltcG9ydCB7U1NSRGVjaWRlcn0gZnJvbSAnLi9wbHVnaW5zL3Nzcic7XG5pbXBvcnQgUm91dGVUYWdzUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9yb3V0ZS10YWdzJztcbmltcG9ydCB7Y2FwdHVyZVN0YWNrVHJhY2UsIERJRXJyb3J9IGZyb20gJy4vc3RhY2stdHJhY2UuanMnO1xuXG5pbXBvcnQge0FwcCBhcyBDb3JlLCBnZXRSZXNvbHZlZERlcH0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7c29ydExlZ2FjeX0gZnJvbSAnLi9sZWdhY3ktY29tcGF0LmpzJztcblxuY2xhc3MgQmFzZUFwcCBleHRlbmRzIENvcmUge1xuICBjb25zdHJ1Y3RvcihlbCwgcmVuZGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWQgPSBuZXcgTWFwKCk7IC8vIGdldFRva2VuUmVmKHRva2VuKSAtPiB7dmFsdWUsIGFsaWFzZXMsIGVuaGFuY2Vyc31cbiAgICB0aGlzLnBsdWdpbnMgPSBbXTsgLy8gVG9rZW5cbiAgICBlbCAmJiB0aGlzLnJlZ2lzdGVyKEVsZW1lbnRUb2tlbiwgZWwpO1xuICAgIGlmIChyZW5kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXI7XG4gICAgfVxuICAgIHRoaXMucmVnaXN0ZXIoU1NSRGVjaWRlclRva2VuLCBTU1JEZWNpZGVyKTtcbiAgICB0aGlzLnJlZ2lzdGVyKFJvdXRlVGFnc1Rva2VuLCBSb3V0ZVRhZ3NQbHVnaW4pO1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICB9XG5cbiAgcmVnaXN0ZXIodG9rZW5PclZhbHVlLCBtYXliZVZhbHVlKSB7XG4gICAgY29uc3QgaGFzVG9rZW4gPSB0b2tlbk9yVmFsdWUgaW5zdGFuY2VvZiBUb2tlbkltcGw7XG4gICAgY29uc3QgdG9rZW4gPSBoYXNUb2tlbiA/IHRva2VuT3JWYWx1ZSA6IGNyZWF0ZVRva2VuKCdVbm5hbWVkUGx1Z2luJyk7XG4gICAgY29uc3QgdmFsdWUgPSBoYXNUb2tlbiA/IG1heWJlVmFsdWUgOiB0b2tlbk9yVmFsdWU7XG4gICAgaWYgKCFoYXNUb2tlbiAmJiAodmFsdWUgPT0gbnVsbCB8fCAhZ2V0UGx1Z2luRm4odmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IERJRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBfX0RFVl9fXG4gICAgICAgICAgPyBgQ2Fubm90IHJlZ2lzdGVyICR7U3RyaW5nKFxuICAgICAgICAgICAgICB0b2tlbk9yVmFsdWVcbiAgICAgICAgICAgICl9IHdpdGhvdXQgYSB0b2tlbi4gRGlkIHlvdSBhY2NpZGVudGFsbHkgcmVnaXN0ZXIgYSAke1xuICAgICAgICAgICAgICBfX05PREVfXyA/ICdicm93c2VyJyA6ICdzZXJ2ZXInXG4gICAgICAgICAgICB9IHBsdWdpbiBvbiB0aGUgJHtfX05PREVfXyA/ICdzZXJ2ZXInIDogJ2Jyb3dzZXInfT9gXG4gICAgICAgICAgOiAnSW52YWxpZCBjb25maWd1cmF0aW9uIHJlZ2lzdHJhdGlvbicsXG4gICAgICAgIGVycm9yRG9jOiAndmFsdWUtd2l0aG91dC10b2tlbicsXG4gICAgICAgIGNhbGxlcjogdGhpcy5yZWdpc3RlcixcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0aGUgcmVuZGVyZXIgaXMgYSBzcGVjaWFsIGNhc2UsIHNpbmNlIGl0IG5lZWRzIHRvIGJlIGFsd2F5cyBydW4gbGFzdFxuICAgIGlmICh0b2tlbiA9PT0gUmVuZGVyVG9rZW4pIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSB2YWx1ZTtcbiAgICAgIGNvbnN0IGFsaWFzID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRElFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ0FsaWFzaW5nIGZvciBSZW5kZXJUb2tlbiBub3Qgc3VwcG9ydGVkJyxcbiAgICAgICAgICBjYWxsZXI6IGFsaWFzLFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge2FsaWFzfTtcbiAgICB9XG4gICAgdG9rZW4uc3RhY2tzLnB1c2goe1xuICAgICAgdHlwZTogJ3JlZ2lzdGVyJyxcbiAgICAgIHN0YWNrOiBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLnJlZ2lzdGVyKSxcbiAgICB9KTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuX19wbHVnaW5fXykge1xuICAgICAgdG9rZW4uc3RhY2tzLnB1c2goe3R5cGU6ICdwbHVnaW4nLCBzdGFjazogdmFsdWUuc3RhY2t9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyKHRva2VuLCB2YWx1ZSk7XG4gIH1cblxuICBfcmVnaXN0ZXIodG9rZW4sIHZhbHVlKSB7XG4gICAgY29uc3QgZm91bmRQbHVnaW5GbiA9IGdldFBsdWdpbkZuKHZhbHVlKTtcblxuICAgIC8vIGNvbnN0IHJlZ2lzdGVyUmVzdWx0ID0gc3VwZXIucmVnaXN0ZXJQbHVnaW4odG9rZW4sIHZhbHVlKTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyUmVzdWx0ID0gc3VwZXIucmVnaXN0ZXJQbHVnaW4oXG4gICAgICB0b2tlbixcbiAgICAgIGZvdW5kUGx1Z2luRm5cbiAgICAgICAgPyBmb3VuZFBsdWdpbkZuXG4gICAgICAgIDogZGVjbGFyZVBsdWdpbihmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIGdldFBsdWdpbkZuKHZhbGF1ZSlcbiAgICAvLyAgID8gc3VwZXIucmVnaXN0ZXJQbHVnaW4odG9rZW4sIHZhbHVlLl9fZm5fXylcbiAgICAvLyAgIDogc3VwZXIucmVnaXN0ZXJQbHVnaW4oXG4gICAgLy8gICAgICAgdG9rZW4sXG4gICAgLy8gICAgICAgZGVjbGFyZVBsdWdpbihmdW5jdGlvbiogKCkge1xuICAgIC8vICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIC8vICAgICAgIH0pXG4gICAgLy8gICAgICk7XG5cbiAgICAvLyBGb3IgaW50cm9zcGVjdCBwbHVnaW5cbiAgICBjb25zdCB7YWxpYXNlcywgZW5oYW5jZXJzfSA9IHRoaXMucmVnaXN0ZXJlZC5nZXQoZ2V0VG9rZW5SZWYodG9rZW4pKSB8fCB7XG4gICAgICBhbGlhc2VzOiBuZXcgTWFwKCksXG4gICAgICBlbmhhbmNlcnM6IFtdLFxuICAgIH07XG4gICAgdGhpcy5yZWdpc3RlcmVkLnNldChnZXRUb2tlblJlZih0b2tlbiksIHtcbiAgICAgIHZhbHVlLFxuICAgICAgYWxpYXNlcyxcbiAgICAgIGVuaGFuY2VycyxcbiAgICAgIHRva2VuLFxuICAgIH0pO1xuXG4gICAgY29uc3QgYWxpYXMgPSAoc291cmNlVG9rZW4sIGRlc3RUb2tlbikgPT4ge1xuICAgICAgcmVnaXN0ZXJSZXN1bHQuYWxpYXMoc291cmNlVG9rZW4sIGRlc3RUb2tlbik7XG4gICAgICBjb25zdCBzdGFjayA9IGNhcHR1cmVTdGFja1RyYWNlKGFsaWFzKTtcbiAgICAgIHNvdXJjZVRva2VuLnN0YWNrcy5wdXNoKHt0eXBlOiAnYWxpYXMtZnJvbScsIHN0YWNrfSk7XG4gICAgICBkZXN0VG9rZW4uc3RhY2tzLnB1c2goe3R5cGU6ICdhbGlhcy10bycsIHN0YWNrfSk7XG4gICAgICByZXR1cm4ge2FsaWFzfTtcbiAgICB9O1xuICAgIHJldHVybiB7YWxpYXN9O1xuICB9XG5cbiAgbWlkZGxld2FyZShkZXBzLCBtaWRkbGV3YXJlKSB7XG4gICAgaWYgKG1pZGRsZXdhcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWlkZGxld2FyZSA9ICgpID0+IGRlcHM7XG4gICAgfVxuICAgIHRoaXMucmVnaXN0ZXIoY3JlYXRlUGx1Z2luKHtkZXBzOiBkZXBzLCBtaWRkbGV3YXJlfSkpO1xuICB9XG5cbiAgZW5oYW5jZSh0b2tlbiwgZW5oYW5jZXIpIHtcbiAgICB0b2tlbi5zdGFja3MucHVzaCh7XG4gICAgICB0eXBlOiAnZW5oYW5jZScsXG4gICAgICBzdGFjazogY2FwdHVyZVN0YWNrVHJhY2UodGhpcy5lbmhhbmNlKSxcbiAgICB9KTtcblxuICAgIC8vIEZvciBpbnRyb3NwZWN0IHBsdWdpblxuICAgIGNvbnN0IHt2YWx1ZSwgYWxpYXNlcywgZW5oYW5jZXJzfSA9IHRoaXMucmVnaXN0ZXJlZC5nZXQoXG4gICAgICBnZXRUb2tlblJlZih0b2tlbilcbiAgICApIHx8IHtcbiAgICAgIGFsaWFzZXM6IG5ldyBNYXAoKSxcbiAgICAgIGVuaGFuY2VyczogW10sXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICBpZiAoZW5oYW5jZXJzICYmIEFycmF5LmlzQXJyYXkoZW5oYW5jZXJzKSkge1xuICAgICAgZW5oYW5jZXJzLnB1c2goZW5oYW5jZXIpO1xuICAgIH1cbiAgICB0aGlzLnJlZ2lzdGVyZWQuc2V0KGdldFRva2VuUmVmKHRva2VuKSwge1xuICAgICAgdmFsdWUsXG4gICAgICBhbGlhc2VzLFxuICAgICAgZW5oYW5jZXJzLFxuICAgICAgdG9rZW4sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3VwZXIuZW5oYW5jZSh0b2tlbiwgZW5oYW5jZXIpO1xuICB9XG5cbiAgY2xlYW51cCgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5jbGVhbnVwcy5tYXAoKGZuKSA9PiBmbigpKSk7XG4gIH1cblxuICByZXNvbHZlKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlZ2lzdHJhdGlvbiBmb3IgUmVuZGVyVG9rZW4nKTtcbiAgICB9XG4gICAgdGhpcy5fcmVnaXN0ZXIoUmVuZGVyVG9rZW4sIHRoaXMucmVuZGVyZXIpO1xuXG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZFRva2Vucy5oYXMoZ2V0VG9rZW5SZWYoRW5hYmxlTWlkZGxld2FyZVRpbWluZ1Rva2VuKSkpIHtcbiAgICAgIHRoaXMuZW5hYmxlTWlkZGxld2FyZVRpbWluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGNvcmUgaW5pdCBhY3R1YWxseSByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAvLyBIb3dldmVyLCBjb3JlIGluaXQgd2lsbCBzeW5jaHJvbm91c2x5IGNvbXBsZXRlIGFzIGxvbmcgYXMgdGhlcmUgaXMgbm9cbiAgICAvLyBhc3luYyB0YXNrcy4gVGhlIG9ubHkgcGxhbm5lZCBhc3luYyBob29rIGlzIHdpdGhTdGFydHVwKCksIHdoaWNoIGlzIG5vdFxuICAgIC8vIGN1cnJlbnRseSBpbXBsZW1lbnRlZC4gSW50cm9kdWNpbmcgYXN5bmMgc3RhcnR1cCBpcyB0ZWNobmljYWxseSBhXG4gICAgLy8gYnJlYWtpbmcgY2hhbmdlLCB3aGljaCB3ZSBhcmUgYXZvaWRpbmcgaW5pdGlhbGx5LiBXaGVuIHdlIHdhbnQgdG8gbWFrZVxuICAgIC8vIHRoaXMgYnJlYWtpbmcgY2hhbmdlIGFuZCBpbnRyb2R1Y2Ugd2l0aFN0YXJ0dXAoKSwgd2Ugc2hvdWxkIGFkZCBhbiBhd2FpdFxuICAgIC8vIHRvIHRoZSBzdGF0ZW1lbnQgYmVsb3dcbiAgICBzdXBlci5pbml0KCk7XG5cbiAgICBzb3J0TGVnYWN5KHRoaXMpOyAvLyBQcmVzZXJ2ZSBsZWdhY3kgb3JkZXIgZm9yIGNvbXBhdGliaWxpdHlcblxuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gIH1cblxuICBnZXRTZXJ2aWNlKHRva2VuKSB7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcbiAgICAgIHRocm93IG5ldyBESUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBnZXQgc2VydmljZSBmcm9tIHVucmVzb2x2ZWQgYXBwJyxcbiAgICAgICAgY2FsbGVyOiB0aGlzLmdldFNlcnZpY2UsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0UmVzb2x2ZWREZXAodGhpcywgdG9rZW4pO1xuICAgIGlmIChyZXN1bHQucmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlQXBwO1xuIl19